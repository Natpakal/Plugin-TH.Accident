# -*- coding: utf-8 -*-
"""
/***************************************************************************
 accident
                                 A QGIS plugin
 accident point
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-03-03
        git sha              : $Format:%H$
        copyright            : (C) 2021 by PSU
        email                : natpakal.123@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction,QFileDialog,QApplication, QDialog,QProgressBar, QPushButton
from qgis.core import QgsProject,QgsVectorLayer, QgsVectorFileWriter, QgsFeature
from PyQt5.QtCore import QThread, pyqtSignal
from qgis.core import *
from qgis.analysis import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .accident_dialog import accidentDialog
import os.path
from accident.api_accident import provide
from datetime import datetime as dt
import requests,json,time,sys,tempfile,shutil,os,shutil
import pandas as pd
import urllib.request
from sys import platform
from accident.vallaris_api import *
import processing

# import geopandas as gpd
# from shapely.geometry import Point, mapping
# from fiona import collection

class accident:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'accident_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&THaccident')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('accident', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/accident/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'&THaccident'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&THaccident'),
                action)
            self.iface.removeToolBarIcon(action)


    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = accidentDialog()
            self.dlg.aa.clicked.connect(self.select_get_years)
            # self.dlg.aa.clicked.connect(self.save_items)
            self.dlg.reset.clicked.connect(self.resetbutton)
            # self.dlg.aa.clicked.connect(self.select_get_ampid)
            self.df2= pd.read_csv('./prov_amp.csv', encoding ='utf-8')
            self.select1()
            self.dlg.prov.currentIndexChanged.connect(self.select_get_amp)
            self.select_get_amp()
            self.dlg.select_folder.clicked.connect(self.saveFileDialog)
            self.dlg.saveLocal.toggled.connect(self.move_frame)
            self.dlg.saveVallaris.toggled.connect(self.move_frame)
            self.dlg.progressBar.hide()
            self.dlg.vallaris.hide()
            self.dlg.show()
            self.dlg.aa.setEnabled(False)
        # show the dialog
        else:
            self.dlg.close()
            self.dlg.show()
        
        # # # Run the dialog event loop
        # # result = self.dlg.exec_()
        # # See if OK was pressed
        # if result:
        #     # selected_city = self.select1.currentText()
        #     # print (selected_city)
        #     # Do something useful here - delete the line containing pass and
        #     # substitute with your code.
        #     pass
    # def finished_(self):
    #     print("finished")
    #     time.sleep(2)
        # self.dlg.progressBar.hide()

    def select1(self):
        path = os.getcwd()
        self.df = provide()

        listprov1 = []
        for index, row in self.df.iterrows():
            listprov1.append(row[0])

        self.dlg.prov.clear()
        self.dlg.prov.addItems(listprov1)
        

        self.dlg.listyears.clear()
        listyears1 = []
        yy = 2005
        y = dt.now()
        for x in range(yy,y.year+1):
            listyears1.append(str(x))
        self.dlg.listyears.addItems(listyears1)
        # return row

    def create_floder(self, dirName):
        if not os.path.exists(dirName):
            os.makedirs(dirName)
            #print("Directory " , dirName ,  " Created ")
            return dirName
        else:    
            #print("Directory " , dirName ,  " already exists")   
            return dirName

    def select_get_years(self):
        connect = self.connect()
        # temp_path = tempfile.gettempdir()
        temp_path = self.create_floder(tempfile.gettempdir()+"/th_accident")
        print(temp_path)
        if connect == 'Connect':
            print("Connect")
            self.dlg.progressBar.show()
            out = self.df2.query('prov == "' + self.prov +'"')
            out_provid = out.values.tolist()[0][2]
            # print(out_provid)


            itemy = self.dlg.listyears.selectedItems()
            self.dlg.progressBar.setValue(20)
            num = []
            datetime = []
            lat = []
            lng = []
            title = []
            detail = []
            for i2 in itemy:
                out_years = i2.text()
                list_output = getdata(out_years)
                num.extend(list_output[0])
                datetime.extend(list_output[1])
                lat.extend(list_output[2])
                lng.extend(list_output[3])
                title.extend(list_output[4])
                detail.extend(list_output[5])
            # itemamp = self.dlg.amp.selectedItems()
                self.dlg.progressBar.setValue(40)
                
            df = pd.DataFrame({'id':num,'datetime':datetime,'lat':lat,'lng':lng,'title':title,'detail':detail})
            # print(df)
            # if self.dlg.saveVallaris.isChecked() == False:
            #     out_csv = self.DirectoryName[0].split(".")[0]
            # # print(out_csv)
            # else:
            #     #save to tamp
            #     temp_out_csv = temp_path + "/th_accident"+str(int(now.timestamp()))+ ".csv"
            temp_out_csv = temp_path + "/th_accident"+str(int(dt.now().timestamp()))+ ".csv"
            df.to_csv(temp_out_csv , encoding="utf-8", index = False, header=True)
            url_ = "file:///"+temp_out_csv+"?encoding=UTF-8&delimiter,&xField=lng&yField=lat&crs=epsg:4326"
            ly_name = str(self.dlg.file.text()).split("/")[-1].split(".")[0]
            layer = QgsVectorLayer(url_,ly_name,"delimitedtext")
            # print(layer.source())
            collectionId ="606ae85498b5b0a75538e73d"

            itemamp = self.dlg.amp.selectedItems()

            wr = get_val(collectionId, self.dlg.prov.currentText(), itemamp)
            clip = temp_path + "/thai_clip"+str(int(dt.now().timestamp())) + ".geojson"
            temp_output = temp_path + "/thai_output"+str(int(dt.now().timestamp())) + ".geojson"
            with open(clip,"w", encoding='utf-8') as cl:
                json.dump(wr,cl)
            param ={
                'INPUT':layer,
                'OVERLAY':clip,
                'OUTPUT':temp_output
            }
            processing.run("native:clip",param )

            layer_tempe = QgsVectorLayer(temp_output,None,"ogr")
            # print(self.DirectoryName[1],112312)
            if self.dlg.saveVallaris.isChecked() == False:
                if self.DirectoryName[1] == "CSV file(*.csv)":
                    exp_crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)
                    writer = QgsVectorFileWriter.writeAsVectorFormat(layer_tempe , self.DirectoryName[0] ,'UTF-8',exp_crs,'CSV',False)
                if self.DirectoryName[1] == "Shapefiles(*.shp)":
                    exp_crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)
                    writer = QgsVectorFileWriter.writeAsVectorFormat(layer_tempe , self.DirectoryName[0] ,'UTF-8',exp_crs,'ESRI Shapefile',False)
                if self.DirectoryName[1] == "GeoJSON(*.geojson)":
                    exp_crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)
                    self.writer = QgsVectorFileWriter.writeAsVectorFormat(layer_tempe , self.DirectoryName[0] ,'UTF-8',exp_crs,'GeoJson',False)
                vlayer = QgsVectorLayer(self.DirectoryName[0],ly_name, "ogr")
        
                if not vlayer.isValid():
                    print("layer_tempe failed to load!")
                else:
                    QgsProject.instance().addMapLayer(vlayer)
            else:
                
                temp_out_geojson = temp_path + "/th_accident"+str(int(dt.now().timestamp()))+".geojson"
                exp_crs = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)
                self.writer = QgsVectorFileWriter.writeAsVectorFormat(layer_tempe , temp_out_geojson+".geojson",'UTF-8',exp_crs,'GeoJson',False)
                with open(temp_out_geojson+".geojson", encoding='utf-8') as fh:
                    data = json.load(fh)
                for dd in data["features"]:
                    dd["properties"].update({"prov_th": self.dlg.prov.currentText()})
                    
                # print(data)
                url = "https://v2k.vallarismaps.com/core/api/1.0-beta/collections/" + self.dlg.collection_id.text() + "/items?api_key=" + self.dlg.api_key.text()   
                # print(self.dlg.collection_id.text())
                # print(self.dlg.api_key.text())
                payload = str(data).replace("'", '"')
                # print(payload)
                headers = {
                'Content-Type': 'application/json',              
                }
                # os.remove(temp_out_geojson)
                response = requests.post(url, headers=headers, data=payload.encode('utf-8'))
                if response.status_code==201:
                    print("OK")
                else:
                    print("fail")
                    
            self.dlg.progressBar.setValue(80)
                
            # os.remove(temp_out_csv)
            
            self.dlg.progressBar.setValue(100)
            # self.dlg.progressBar.hide()
            # # self.finished_()
            try:
                shutil.rmtree(temp_path, ignore_errors=True)

            except:
                pass

    
        else :
            print(connect)
  
    def select_get_amp(self):
        self.prov = self.dlg.prov.currentText()
        
        out2 = self.df2.query('prov == "' + self.prov+'"')
        # print(out2)
        outlist = out2.values.tolist()
        # print(outlist)
        amp1 = []
        for index1 in outlist:
            # print(index1[2])  
                
            amp1.append(str(index1[3]))
        
        self.dlg.amp.clear()
        self.dlg.amp.addItems(amp1) 

    def saveFileDialog(self):
        try:
            ## macos ##
            path = "/Users"
            filter = "CSV file(*.csv);;Shapefiles(*.shp);;GeoJSON(*.geojson)"
            DirectoryName = QFileDialog.getSaveFileName(None,'Save file',path,filter)
            print(DirectoryName[0])
            if DirectoryName[0] == '':
                # self.dlg.aa.setEnabled(False)
                print('Error select folder')
            else :
                self.dlg.aa.setEnabled(True)
                if DirectoryName:
                    self.dlg.file.setText(DirectoryName[0])
                    self.DirectoryName = DirectoryName
        except:
            ## window ##
            path = r"C:\\"
            filter = "CSV file(*.csv);;Shapefiles(*.shp);;GeoJSON(*.geojson)"
            DirectoryName = QFileDialog.getSaveFileName(None,'Save file',path,filter)
            # print(DirectoryName[0])
            if DirectoryName[0] == '':
                # self.dlg.aa.setEnabled(False)
                print('Error select folder')
            else :
                self.dlg.aa.setEnabled(True)
                if DirectoryName:
                    self.dlg.file.setText(DirectoryName[0])
                    self.DirectoryName = DirectoryName
            
           
    def reset(self, amp):
        for i in range(amp.count()):
            # print(i)
            item = amp.item(i)
            item.setSelected(False)
        
    def resetbutton(self):
        self.select_get_amp()
        self.reset(self.dlg.amp)
        self.reset(self.dlg.listyears)
        self.dlg.progressBar.setValue(0)

    def connect(self, host='http://google.com'):
        try:
            urllib.request.urlopen(host)
            return 'Connect'
        except:
            return 'Disconect'

    def move_frame(self):
        if self.dlg.saveLocal.isChecked() == True:
            self.dlg.aa.setEnabled(False)
            self.dlg.label_4.show()
            self.dlg.file.show()
            self.dlg.select_folder.show()
            self.dlg.vallaris.hide()
            self.dlg.setMinimumSize(408,457)
            self.dlg.setMaximumSize(408,457)
            self.dlg.frame.setMinimumSize(390,440)
            self.dlg.frame.setMaximumSize(390,440)
            self.dlg.run_frame.move(30,380)
        else:
            self.dlg.aa.setEnabled(True)
            self.dlg.label_4.hide()
            self.dlg.file.hide()
            self.dlg.select_folder.hide()
            self.dlg.vallaris.show()
            self.dlg.setMinimumSize(408,510)
            self.dlg.setMaximumSize(408,510)
            self.dlg.frame.setMinimumSize(390,490)
            self.dlg.frame.setMaximumSize(390,490)
            self.dlg.run_frame.move(30,430)

    
           
        
                        

        

    

        

        
        

